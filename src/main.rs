use clarity::vm::Value;
use wasmtime::{
    AsContextMut, Config, Engine, Extern, ExternRef, Func, Instance, Module, Store, Val,
};

mod wasm_generator;

fn main() {
    // Generate a wasm module (see `wasm_generator.rs`) which has a `toplevel` function
    // which in turn calls the below defined wrapped function `func`.
    let wasm_bytes = wasm_generator::generate_wasm();

    // Initialize config which allows for reference types.
    let mut config = Config::new();
    config.wasm_reference_types(true);

    // Initialize the wasmtime engine.
    let engine = Engine::new(&config).expect("Failed to initialize engine");

    // Initialize the wasmtime store (using a custom state type).
    let state = MyApplicationState {};
    let mut store = Store::new(&engine, state);

    // Load the module generated above.
    let module = Module::from_binary(store.engine(), &wasm_bytes).expect("Failed to load module");

    // This defines a HOST function which receives ExternRef values and adds them together, returning the result.
    // This code only handles sunny-day, i.e. if it isn't two `Value::Int(_)`'s it'll blow up. A proper impl.
    // would use a `match` statement and handle Int/UInt accordingly.
    // NOTE: !!!  ExternRef input arguments and return values must be provided as `Options`s.
    let func = Func::wrap(
        store.as_context_mut(),
        |a: Option<ExternRef>, b: Option<ExternRef>| {
            let a = a.unwrap();
            let b = b.unwrap();

            println!("Input (a: {:?}, b: {:?})", a, b);

            let result = match a.data().downcast_ref::<Value>() {
                Some(Value::Int(int_a)) => {
                    if let Some(Value::Int(int_b)) = b.data().downcast_ref::<Value>() {
                        Some(ExternRef::new(Value::Int(int_a + int_b)))
                    } else {
                        panic!("Value type mismatch");
                    }
                }
                Some(Value::UInt(uint_a)) => {
                    if let Some(Value::UInt(uint_b)) = b.data().downcast_ref::<Value>() {
                        Some(ExternRef::new(Value::UInt(uint_a + uint_b)))
                    } else {
                        panic!("Value type mismatch");
                    }
                }
                _ => panic!("Invalid type..."),
            };

            Ok(result)
        },
    );

    // Create an `Extern` of the `add` function (needed to pass as an imported function in the next step).
    let add = Extern::Func(func);

    // We create a new instance and pass in any imported (host) functions (in this case, only `add`).
    let instance =
        Instance::new(&mut store, &module, &[add]).expect("Couldn't create new module instance");

    // This would be where we prepare to call a contract function. In this case, `toplevel` (as defined)
    // in the WASM generated by `wasm_generator`. We'll pass two Clarity `Value::Int`'s (1, 2) and
    // receive a `Value::Int` back (3).
    let instance_fn = instance
        .get_func(&mut store, "toplevel")
        .expect("Failed to get fn");

    // Define our output parameters. Note that we're using `Option`s as stated above.
    let results = &mut [
        Val::ExternRef(Some(ExternRef::new(Value::none()))), // Option<ExternRef>
    ];

    // * * * * * * * * * * * * *
    // Call the function using `Int`s.
    // * * * * * * * * * * * * *
    instance_fn
        .call(
            &mut store,
            &[
                Val::ExternRef(Some(ExternRef::new(Value::Int(1)))), // Option<ExternRef>
                Val::ExternRef(Some(ExternRef::new(Value::Int(2)))), // Option<ExternRef>
            ],
            results,
        )
        .expect("Failed to call function");

    // Results..
    println!("Results: {:?}", results);
    let result_unwrapped = results[0].unwrap_externref().unwrap();

    let result = result_unwrapped.data().downcast_ref::<Value>().unwrap();
    println!("Result: {:?}", result);

    // * * * * * * * * * * * * *
    // Call the function using `UInt`s.
    // * * * * * * * * * * * * *
    instance_fn
        .call(
            &mut store,
            &[
                Val::ExternRef(Some(ExternRef::new(Value::UInt(5)))), // Option<ExternRef>
                Val::ExternRef(Some(ExternRef::new(Value::UInt(6)))), // Option<ExternRef>
            ],
            results,
        )
        .expect("Failed to call function");

    // Results..
    println!("Results: {:?}", results);
    let result_unwrapped = results[0].unwrap_externref().unwrap();

    let result = result_unwrapped.data().downcast_ref::<Value>().unwrap();
    println!("Result: {:?}", result);
}

#[derive(Debug, Copy, Clone)]
struct MyApplicationState {}
