use clarity::vm::Value;
use wasmtime::{
    AsContextMut, Config, Engine, Extern, ExternRef, Func, Instance, Module, Store, Val,
};

mod wasm_generator;

fn main() {
    // Generate a wasm module (see `wasm_generator.rs`) which has a `toplevel` function
    // which in turn calls the below defined wrapped function `func`.
    let wasm_bytes = wasm_generator::generate_wasm();

    // Initialize config which allows for reference types.
    let mut config = Config::new();
    config.wasm_reference_types(true);

    // Initialize the wasmtime engine.
    let engine = Engine::new(&config).expect("Failed to initialize engine");

    // Initialize the wasmtime store (using a custom state type).
    let state = MyApplicationState {};
    let mut store = Store::new(&engine, state);

    // Load the module generated above.
    let module = Module::from_binary(&store.engine(), &wasm_bytes).expect("Failed to load module");

    // This defines a HOST function which receives ExternRef values and adds them together, returning the result.
    // This code only handles sunny-day, i.e. if it isn't two `Value::Int(_)`'s it'll blow up. A proper impl.
    // would use a `match` statement and handle Int/UInt accordingly.
    let func = Func::wrap(
        store.as_context_mut(),
        |a: Option<ExternRef>, b: Option<ExternRef>| {
            let a = a.unwrap();
            let b = b.unwrap();
            let input_a = a.data().downcast_ref::<Value>().unwrap();
            let input_b = b.data().downcast_ref::<Value>().unwrap();
            println!("Input: a={:?}, b={:?}", input_a, input_b);

            let result = Value::Int(input_a.clone().expect_i128() + input_b.clone().expect_i128());
            println!("Inner result: {:?}", result);

            let retopt: Option<ExternRef> = Some(ExternRef::new(result));
            println!("Inner ret: {:?}", retopt);

            Ok(retopt)
        },
    );

    // Create an `Extern` of the `add` function (needed to pass as an imported function in the next step).
    let add = Extern::Func(func);

    // We create a new instance and pass in any imported (host) functions (in this case, only `add`).
    let instance =
        Instance::new(&mut store, &module, &[add]).expect("Couldn't create new module instance");

    // This would be where we prepare to call a contract function. In this case, `toplevel` (as defined)
    // in the WASM generated by `wasm_generator`. We'll pass two Clarity `Value::Int`'s (1, 2) and
    // receive a `Value::Int` back (3).
    let instance_fn = instance
        .get_func(&mut store, "toplevel")
        .expect("Failed to get fn");

    // Define our input params...
    let param_a = Some(ExternRef::new(Value::Int(1)));
    let param_b = Some(ExternRef::new(Value::Int(2)));

    // .. and our output params..
    let result_val = Some(ExternRef::new(Value::Int(0)));
    let results = &mut [Val::ExternRef(result_val)];

    // Call the function.
    instance_fn
        .call(
            &mut store,
            &[Val::ExternRef(param_a), Val::ExternRef(param_b)],
            results,
        )
        .expect("Failed to call function");

    // Results..
    println!("Results: {:?}", results);
    let result_unwrapped = results[0].unwrap_externref().unwrap();
    let result = result_unwrapped.data().downcast_ref::<Value>().unwrap();
    println!("Result: {:?}", result);
}

#[derive(Debug, Copy, Clone)]
struct MyApplicationState {}
