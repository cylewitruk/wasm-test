use std::time::Instant;

use clarity::vm::{types::SequenceData, Value};
use wasmtime::{
    AsContext, AsContextMut, Caller, Config, Engine, Extern, ExternRef, Func, Instance, Module,
    Store, Val,
};

mod wasm_generator;
#[cfg(test)]
mod tests;

fn main() {
    // Generate a wasm module (see `wasm_generator.rs`) which has a `toplevel` function
    // which in turn calls the below defined wrapped function `func`.
    let wasm_bytes = wasm_generator::generate_wasm();

    // Initialize config which allows for reference types.
    let mut config = Config::new();
    config.wasm_reference_types(true);

    // Initialize the wasmtime engine.
    let engine = Engine::new(&config).expect("Failed to initialize engine");

    // Initialize the wasmtime store (using a custom state type).
    let state = MyApplicationState {};
    let mut store = Store::new(&engine, state);

    // Load the module generated above.
    let module = Module::from_binary(store.engine(), &wasm_bytes).expect("Failed to load module");

    // Get our list of host functions to be included in the instance.
    let imports = define_functions::<MyApplicationState>(&mut store);

    // We create a new instance and pass in any imported (host) functions.
    let instance =
        Instance::new(&mut store, &module, &imports).expect("Couldn't create new module instance");

    // This would be where we prepare to call a contract function. In this case, `fold-add-square` (as defined)
    // in the WASM generated by `wasm_generator`.
    let instance_fn = instance
        .get_func(&mut store, "fold-add-square")
        .expect("Failed to get fn");

    // Define our output parameters. Note that we're using `Option`s as stated above.
    let results = &mut [
        Val::ExternRef(Some(ExternRef::new(Value::none()))), // Option<ExternRef>
    ];

    // Define our input parameters.
    let mut sequence_values = Vec::<Value>::with_capacity(8192);
    for i in 1..8193 {
        sequence_values.push(Value::Int(i));
    }
    let sequence = Value::list_from(sequence_values)
        .expect("Failed to create list");
    let init = Value::Int(1);

    // * * * * * * * * * * * * *
    // Call the function
    // * * * * * * * * * * * * *
    let start = Instant::now();
    instance_fn
        .call(
            &mut store,
            &[
                Val::ExternRef(Some(ExternRef::new(sequence))), // Option<ExternRef>
                Val::ExternRef(Some(ExternRef::new(init))), // Option<ExternRef>
            ],
            results,
        )
        .expect("Failed to call function");
    let duration = Instant::now() - start;

    // Results..
    let result_unwrapped = results[0].unwrap_externref().unwrap();
    let result = result_unwrapped.data().downcast_ref::<Value>().unwrap();
    println!("Result: {:?}; Time: {:?}", result, duration);
}

fn define_functions<T>(mut store: impl AsContextMut<Data = T>) -> Vec<Extern> {
    let mut externs = Vec::<Extern>::new();

    // NOTE: `ExternRef`s and `FuncRef`s must be passed as `Option`s in Wasmtime to be properly
    // type converted by the runtime.

    // This defines a HOST function which receives ExternRef values and adds them together, returning the result.
    let fn_add = Func::wrap(&mut store, |a: Option<ExternRef>, b: Option<ExternRef>| {
        let a = a.unwrap();
        let b = b.unwrap();

        let result = match a.data().downcast_ref::<Value>() {
            Some(Value::Int(int_a)) => {
                if let Some(Value::Int(int_b)) = b.data().downcast_ref::<Value>() {
                    let result = int_a.checked_add(*int_b).expect("Failed to add");
                    //println!("[add] Input a = {int_a}, b = {int_b}; Result = {result}");
                    Some(ExternRef::new(Value::Int(result)))
                } else {
                    panic!("[add] Value type mismatch (int): b = {:?}", b.data().downcast_ref::<Value>());
                }
            }
            Some(Value::UInt(uint_a)) => {
                if let Some(Value::UInt(uint_b)) = b.data().downcast_ref::<Value>() {
                    Some(ExternRef::new(Value::UInt(uint_a + uint_b)))
                } else {
                    panic!("Value type mismatch");
                }
            }
            _ => panic!("Invalid type..."),
        };

        Ok(result)
    });

    // Define the `mul` (multiply) host function.
    let fn_mul = Func::wrap(&mut store, |a: Option<ExternRef>, b: Option<ExternRef>| {
        let a = a.unwrap();
        let b = b.unwrap();

        let result = match a.data().downcast_ref::<Value>() {
            Some(Value::Int(int_a)) => {
                if let Some(Value::Int(int_b)) = b.data().downcast_ref::<Value>() {
                    let result = int_a.checked_mul(*int_b).expect("Failed to multiply");
                    //println!("[mul] Input a = {int_a}, b = {int_b}; Result = {result}");
                    Some(ExternRef::new(Value::Int(result)))
                } else {
                    panic!("[mul] Value type mismatch (int): b = {:?}", b.data().downcast_ref::<Value>());
                }
            }
            Some(Value::UInt(uint_a)) => {
                if let Some(Value::UInt(uint_b)) = b.data().downcast_ref::<Value>() {
                    Some(ExternRef::new(Value::UInt(
                        uint_a.checked_mul(*uint_b).expect("Fail"),
                    )))
                } else {
                    panic!("Value type mismatch (uint)");
                }
            }
            _ => panic!("Invalid type..."),
        };

        Ok(result)
    });

    // Define the `fold` host function.
    let fn_fold = Func::wrap(
        &mut store,
        |mut caller: Caller<'_, T>,
         func: Option<Func>,
         seq: Option<ExternRef>,
         init: Option<ExternRef>| {
            let func = func.unwrap();
            let seq = seq.unwrap();
            let init = init.unwrap();

            let fn_type = func.ty(caller.as_context());
            debug_assert_eq!(fn_type.params().len(), 2);
            debug_assert_eq!(fn_type.results().len(), 1);

            let result = match seq.data().downcast_ref::<Value>().unwrap() {
                Value::Sequence(SequenceData::List(list)) => {
                    let result = list.data.iter().fold(init, |acc, val| {
                        let acc_value = acc.data().downcast_ref::<Value>();
                        let val_ref = Some(ExternRef::new(val.clone()));
                        //println!("acc: {:?}, acc_value: {:?}, val: {:?}", &acc.data(), &acc_value, &val);

                        // Define our output parameters to be used for each iteration of fold.
                        let results = &mut [
                            Val::ExternRef(Some(ExternRef::new(Value::none()))), // Option<ExternRef>
                        ];
                        
                        func.call(
                            &mut caller, 
                            &[Val::ExternRef(val_ref), Val::ExternRef(Some(acc))], 
                            results
                        ).expect("Failed to call fold inner function");

                        // TODO: Verify that the returned value is of the same type as `init`.
                        results[0].unwrap_externref().unwrap()
                    });
                    Some(result)
                }
                Value::Sequence(SequenceData::Buffer(_buff)) => {
                    todo!();
                }
                Value::Sequence(SequenceData::String(_str)) => {
                    todo!();
                }
                _ => panic!("Not a valid sequence type"),
            };

            Ok(result)
        },
    );

    // Create `Extern`s for each of the functions and return the list.
    externs.append(&mut vec![
        Extern::Func(fn_add),
        Extern::Func(fn_mul),
        Extern::Func(fn_fold),
    ]);
    externs
}

#[derive(Debug, Copy, Clone)]
struct MyApplicationState {}
