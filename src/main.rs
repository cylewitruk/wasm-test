
use clarity::vm::Value;
use wasmtime::{AsContextMut, ExternRef, Config, Engine, Store, Module, Extern, Instance, Val, Func};

mod wasm_generator;

fn main() {
    // Generate a wasm module (see `wasm_generator.rs`) which has a `toplevel` function
    // which in turn calls the below defined wrapped function `func`.
    let wasm_bytes = wasm_generator::generate_wasm();

    // Initialize config which allows for reference types.
    let mut config = Config::new();
    config.wasm_reference_types(true);

    // Initialize the wasmtime engine.
    let engine = Engine::new(&config).expect("Failed to initialize engine");

    // Initialize the wasmtime store (using a custom state type).
    let state = MyApplicationState{};
    let mut store = Store::new(&engine, state);

    // Load the module generated above.
    let module = Module::from_binary(&store.engine(), &wasm_bytes)
        .expect("Failed to load module");

    // This defines a function which receives ExternRef values and adds them together, returning the result.
    // This code only handles sunny-day, i.e. if it isn't two `Value::Int(_)`'s it'll blow up. A proper impl.
    // would use a `match` statement and handle Int/UInt accordingly.
    let func = Func::wrap(store.as_context_mut(), |a: Option<ExternRef>, b: Option<ExternRef>| {
        let a = a.unwrap();
        let b = b.unwrap();
        let input_a = a.data().downcast_ref::<Value>().unwrap();
        let input_b = b.data().downcast_ref::<Value>().unwrap();
        println!("Input: a={:?}, b={:?}", input_a, input_b);

        let result = Value::Int(input_a.clone().expect_i128() + input_b.clone().expect_i128());
        println!("Inner result: {:?}", result);
        
        let retopt: Option<ExternRef> = Some(ExternRef::new(result));
        println!("Inner ret: {:?}", retopt);

        Ok(retopt)
    });

    // Create an `Extern` of the `add` function.
    let add = Extern::Func(func);
    
    // We create a new instance and pass in any imported functions (in this case, only `add`).
    let instance = Instance::new(&mut store, &module, &[add])
        .expect("Couldn't create new module instance");

    // This would be where we prepare to call a contract function. In this case, `toplevel` (as defined)
    // in the WASM generated by `wasm_generator`. We'll pass two Clarity `Value::Int`'s (1, 2) and
    // receive a `Value::Int` back (3).
    let instance_fn = instance.get_func(&mut store, "toplevel")
        .expect("Failed to get fn");

    let param_a = Some(ExternRef::new(Value::Int(1)));
    let param_b = Some(ExternRef::new(Value::Int(2)));

    let result_val = Some(ExternRef::new(Value::Int(0)));
    let results = &mut [Val::ExternRef(result_val)];

    // Call the function.
    instance_fn.call(&mut store, 
        &[Val::ExternRef(param_a), Val::ExternRef(param_b)], 
        results)
        .expect("Failed to call function");

    // Results..
    println!("Results: {:?}", results);
    let result_unwrapped = results[0].unwrap_externref().unwrap();
    let result = result_unwrapped.data().downcast_ref::<Value>().unwrap();
    println!("Result: {:?}", result);
}

#[derive(Debug, Copy, Clone)]
struct MyApplicationState {
}
