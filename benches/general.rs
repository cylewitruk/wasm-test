use clarity::vm::Value;
use criterion::{criterion_group, criterion_main, Criterion};
use wasmtime::{Module, Engine, Config, Store, Instance, Val, ExternRef, Extern};
use wasm_test::{ClarityWasmContext, wasm_generator, get_all_functions};

pub fn criterion_benchmark(c: &mut Criterion) {
    // Generate a wasm module (see `wasm_generator.rs`) which has a `toplevel` function
    // which in turn calls the below defined wrapped function `func`.
    let wasm_bytes = wasm_generator::generate_wasm();

    // Initialize config which allows for reference types.
    let mut config = Config::new();
    config.wasm_reference_types(true);

    // Initialize the wasmtime engine.
    let engine = Engine::new(&config).expect("Failed to initialize engine");

    // Pre-compile the module.
    let precompiled = engine.precompile_module(&wasm_bytes)
        .expect("Failed to precompile module");

    // Initialize the wasmtime store (using a custom state type).
    let state = ClarityWasmContext {};
    let mut store = Store::new(&engine, state);

    // Load the module generated above.
    //let module = Module::from_binary(store.engine(), &wasm_bytes).expect("Failed to load module");
    let module = unsafe { 
        Module::deserialize(&engine, &precompiled)
            .expect("Failed to load module") 
    };

    // Get our list of host functions to be included in the instance.
    let imports = get_all_functions(&mut store);
    // Convert the (name, func) pairs to a vec of `Export`s (needed for the Instance).
    let imports = imports.into_iter()
        .map(|f| Extern::Func(f.func))
        .collect::<Vec<Extern>>();

    // We create a new instance and pass in any imported (host) functions.
    let instance =
        Instance::new(&mut store, &module, &imports).expect("Couldn't create new module instance");

    // This would be where we prepare to call a contract function. In this case, `fold-add-square` (as defined)
    // in the WASM generated by `wasm_generator`.
    let instance_fn = instance
        .get_func(&mut store, "fold-add-square")
        .expect("Failed to get fn");

    // Define our output parameters. Note that we're using `Option`s as stated above.
    let results = &mut [
        Val::ExternRef(Some(ExternRef::new(Value::none()))), // Option<ExternRef>
    ];
    
    c.bench_function(
        "fold-add-square", 
        |b| {
            b.iter(|| {
                // Define our input parameters.
                let mut sequence_values = Vec::<Value>::with_capacity(8192);
                for i in 1..8193 {
                    sequence_values.push(Value::Int(i));
                }
                
                let sequence = Value::list_from(sequence_values)
                    .expect("Failed to create list");
                let init = Value::Int(1);

                instance_fn
                    .call(
                        &mut store,
                        &[
                            Val::ExternRef(Some(ExternRef::new(sequence))), // Option<ExternRef>
                            Val::ExternRef(Some(ExternRef::new(init))), // Option<ExternRef>
                        ],
                        results,
                    )
                    .expect("Failed to call function")
            })
        });
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);